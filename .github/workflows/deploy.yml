name: Deploy to Azure

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  JAVA_VERSION: '21'
  JAVA_DISTRIBUTION: 'temurin'
  ACR_NAME: 'acrquizapp123'
  POSTGRES_SERVER_NAME: 'psql-quiz-app-123'
  POSTGRES_ADMIN_USERNAME: 'quizadmin'
  KEY_VAULT_NAME: 'kv-quiz-app'
  # Terraform state storage
  TF_STATE_RESOURCE_GROUP: 'rg-terraform-state'
  TF_STATE_STORAGE_ACCOUNT: 'tfstatequizapp'
  TF_STATE_CONTAINER: 'tfstate'
  TF_STATE_KEY: 'quiz-app.tfstate'

jobs:
  test:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: maven

      - name: Run tests
        working-directory: ./quizapp
        run: ./mvnw test

  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      acr_login_server: ${{ steps.terraform_output.outputs.acr_login_server }}
      postgres_fqdn: ${{ steps.terraform_output.outputs.postgres_fqdn }}
      postgres_database: ${{ steps.terraform_output.outputs.postgres_database }}
      resource_group: ${{ steps.terraform_output.outputs.resource_group }}
      container_app_name: ${{ steps.terraform_output.outputs.container_app_name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Extract Azure Credentials
        id: azure_creds
        run: |
          echo "client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')" >> $GITHUB_OUTPUT
          echo "client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')" >> $GITHUB_OUTPUT
          echo "subscription_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')" >> $GITHUB_OUTPUT
          echo "tenant_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ensure Terraform State Storage Exists
        run: |
          # Check if resource group exists
          if ! az group show --name ${{ env.TF_STATE_RESOURCE_GROUP }} &> /dev/null; then
            echo "Creating resource group for Terraform state..."
            az group create \
              --name ${{ env.TF_STATE_RESOURCE_GROUP }} \
              --location westus
          else
            echo "Resource group ${{ env.TF_STATE_RESOURCE_GROUP }} already exists"
          fi
          
          # Check if storage account exists
          if ! az storage account show \
            --name ${{ env.TF_STATE_STORAGE_ACCOUNT }} \
            --resource-group ${{ env.TF_STATE_RESOURCE_GROUP }} &> /dev/null; then
            echo "Creating storage account for Terraform state..."
            az storage account create \
              --name ${{ env.TF_STATE_STORAGE_ACCOUNT }} \
              --resource-group ${{ env.TF_STATE_RESOURCE_GROUP }} \
              --location westus \
              --sku Standard_LRS \
              --encryption-services blob
          else
            echo "Storage account ${{ env.TF_STATE_STORAGE_ACCOUNT }} already exists"
          fi
          
          # Check if container exists
          if ! az storage container show \
            --name ${{ env.TF_STATE_CONTAINER }} \
            --account-name ${{ env.TF_STATE_STORAGE_ACCOUNT }} &> /dev/null; then
            echo "Creating container for Terraform state..."
            az storage container create \
              --name ${{ env.TF_STATE_CONTAINER }} \
              --account-name ${{ env.TF_STATE_STORAGE_ACCOUNT }}
          else
            echo "Container ${{ env.TF_STATE_CONTAINER }} already exists"
          fi

      - name: Get Storage Account Key
        id: storage_key
        run: |
          STORAGE_KEY=$(az storage account keys list \
            --resource-group ${{ env.TF_STATE_RESOURCE_GROUP }} \
            --account-name ${{ env.TF_STATE_STORAGE_ACCOUNT }} \
            --query '[0].value' \
            --output tsv)
          echo "::add-mask::$STORAGE_KEY"
          echo "key=$STORAGE_KEY" >> $GITHUB_OUTPUT

      - name: Terraform Init
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
          ARM_ACCESS_KEY: ${{ steps.storage_key.outputs.key }}
        run: terraform init

      - name: Terraform Plan
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
          TF_VAR_acr_name: ${{ env.ACR_NAME }}
          TF_VAR_postgres_server_name: ${{ env.POSTGRES_SERVER_NAME }}
          TF_VAR_postgres_admin_username: ${{ env.POSTGRES_ADMIN_USERNAME }}
          TF_VAR_key_vault_name: ${{ env.KEY_VAULT_NAME }}
        run: terraform plan -target=azurerm_resource_group.main -target=azurerm_container_registry.main -target=random_password.postgres_admin -target=azurerm_postgresql_flexible_server.main -target=azurerm_postgresql_flexible_server_database.main -target=azurerm_postgresql_flexible_server_firewall_rule.azure_services -target=azurerm_log_analytics_workspace.main -target=azurerm_container_app_environment.main -target=azurerm_key_vault.main -target=azurerm_role_assignment.terraform_keyvault_admin -target=azurerm_key_vault_secret.postgres_password

      - name: Terraform Apply (Infrastructure Only)
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
          TF_VAR_acr_name: ${{ env.ACR_NAME }}
          TF_VAR_postgres_server_name: ${{ env.POSTGRES_SERVER_NAME }}
          TF_VAR_postgres_admin_username: ${{ env.POSTGRES_ADMIN_USERNAME }}
          TF_VAR_key_vault_name: ${{ env.KEY_VAULT_NAME }}
        run: terraform apply -target=azurerm_resource_group.main -target=azurerm_container_registry.main -target=random_password.postgres_admin -target=azurerm_postgresql_flexible_server.main -target=azurerm_postgresql_flexible_server_database.main -target=azurerm_postgresql_flexible_server_firewall_rule.azure_services -target=azurerm_log_analytics_workspace.main -target=azurerm_container_app_environment.main -target=azurerm_key_vault.main -target=azurerm_role_assignment.terraform_keyvault_admin -target=azurerm_key_vault_secret.postgres_password -auto-approve

      - name: Get Terraform Outputs
        id: terraform_output
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
        run: |
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "postgres_fqdn=$(terraform output -raw postgres_fqdn)" >> $GITHUB_OUTPUT
          echo "postgres_database=$(terraform output -raw postgres_database_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "container_app_name=$(terraform output -raw container_app_name)" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: maven

      - name: Build with Maven
        working-directory: ./quizapp
        run: ./mvnw clean package -DskipTests

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: |
          az acr login --name $(echo ${{ needs.terraform.outputs.acr_login_server }} | cut -d'.' -f1)

      - name: Build and Push Docker Image
        working-directory: ./quizapp
        env:
          ACR_LOGIN_SERVER: ${{ needs.terraform.outputs.acr_login_server }}
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t $ACR_LOGIN_SERVER/quiz-app:$IMAGE_TAG .
          docker tag $ACR_LOGIN_SERVER/quiz-app:$IMAGE_TAG $ACR_LOGIN_SERVER/quiz-app:latest
          docker push $ACR_LOGIN_SERVER/quiz-app:$IMAGE_TAG
          docker push $ACR_LOGIN_SERVER/quiz-app:latest
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Save image tag
        run: echo "${{ github.sha }}" > image-tag.txt

      - name: Upload image tag artifact
        uses: actions/upload-artifact@v4
        with:
          name: image-tag
          path: image-tag.txt

  migrate-database:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: terraform
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: maven

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Add firewall rule for GitHub Actions runner
        env:
          RESOURCE_GROUP: ${{ needs.terraform.outputs.resource_group }}
          POSTGRES_SERVER: ${{ env.POSTGRES_SERVER_NAME }}
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "Runner IP: $RUNNER_IP"
          az postgres flexible-server firewall-rule create \
            --resource-group $RESOURCE_GROUP \
            --name $POSTGRES_SERVER \
            --rule-name "AllowGitHubActions" \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP

      - name: Get PostgreSQL Password from Key Vault
        id: get_postgres_password
        run: |
          KV_NAME=$(az keyvault list --resource-group rg-quiz-app --query "[0].name" -o tsv)
          PASSWORD=$(az keyvault secret show --vault-name $KV_NAME --name postgres-admin-password --query value -o tsv)
          echo "::add-mask::$PASSWORD"
          echo "password=$PASSWORD" >> $GITHUB_OUTPUT

      - name: Run Flyway Migrations
        working-directory: ./quizapp
        env:
          POSTGRES_FQDN: ${{ needs.terraform.outputs.postgres_fqdn }}
          POSTGRES_DATABASE: ${{ needs.terraform.outputs.postgres_database }}
          POSTGRES_USER: ${{ env.POSTGRES_ADMIN_USERNAME }}
          POSTGRES_PASSWORD: ${{ steps.get_postgres_password.outputs.password }}
        run: |
          ./mvnw flyway:migrate \
            -Dflyway.url=jdbc:postgresql://$POSTGRES_FQDN:5432/$POSTGRES_DATABASE?sslmode=require \
            -Dflyway.user=$POSTGRES_USER \
            -Dflyway.password=$POSTGRES_PASSWORD \
            -Dflyway.locations=filesystem:src/main/resources/db/migration

      - name: Remove firewall rule
        if: always()
        env:
          RESOURCE_GROUP: ${{ needs.terraform.outputs.resource_group }}
          POSTGRES_SERVER: ${{ env.POSTGRES_SERVER_NAME }}
        run: |
          az postgres flexible-server firewall-rule delete \
            --resource-group $RESOURCE_GROUP \
            --name $POSTGRES_SERVER \
            --rule-name "AllowGitHubActions" \
            --yes

  deploy-app:
    name: Deploy Container App
    runs-on: ubuntu-latest
    needs: [terraform, build-and-push, migrate-database]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Download image tag artifact
        uses: actions/download-artifact@v4
        with:
          name: image-tag

      - name: Read image tag
        id: image_tag
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Extract Azure Credentials
        id: azure_creds
        run: |
          echo "client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')" >> $GITHUB_OUTPUT
          echo "client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')" >> $GITHUB_OUTPUT
          echo "subscription_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')" >> $GITHUB_OUTPUT
          echo "tenant_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')" >> $GITHUB_OUTPUT

      - name: Terraform Init
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
        run: terraform init

      - name: Deploy Container App with Terraform
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
          TF_VAR_acr_name: ${{ env.ACR_NAME }}
          TF_VAR_postgres_server_name: ${{ env.POSTGRES_SERVER_NAME }}
          TF_VAR_postgres_admin_username: ${{ env.POSTGRES_ADMIN_USERNAME }}
          TF_VAR_key_vault_name: ${{ env.KEY_VAULT_NAME }}
          TF_VAR_app_image_tag: ${{ steps.image_tag.outputs.tag }}
        run: |
          # First, create the Container App (without role assignment)
          terraform apply -target=azurerm_container_app.main -auto-approve
          
          # Then, create the role assignment (now identity exists)
          terraform apply -auto-approve
          
          # Force Container App restart to pick up Key Vault access
          # (App may have failed to start initially due to missing role assignment)
          az containerapp revision restart \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group $(terraform output -raw resource_group_name) \
            --revision $(az containerapp revision list \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group $(terraform output -raw resource_group_name) \
              --query '[0].name' -o tsv) || true

      - name: Restart Container App
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
        working-directory: ./infra
        run: |
          # Authenticate Azure CLI
          az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID
          az account set --subscription $ARM_SUBSCRIPTION_ID
          
          # Get resource names from Terraform outputs
          RG_NAME=$(terraform output -raw resource_group_name)
          APP_NAME=$(terraform output -raw container_app_name)
          
          # Get the current active revision and restart it
          REVISION=$(az containerapp revision list \
            --name $APP_NAME \
            --resource-group $RG_NAME \
            --query '[0].name' -o tsv)
          
          echo "Restarting Container App revision: $REVISION"
          az containerapp revision restart \
            --name $APP_NAME \
            --resource-group $RG_NAME \
            --revision $REVISION || echo "Restart command not available, container will restart on next update"

      - name: Get Container App URL
        working-directory: ./infra
        env:
          ARM_CLIENT_ID: ${{ steps.azure_creds.outputs.client_id }}
          ARM_CLIENT_SECRET: ${{ steps.azure_creds.outputs.client_secret }}
          ARM_SUBSCRIPTION_ID: ${{ steps.azure_creds.outputs.subscription_id }}
          ARM_TENANT_ID: ${{ steps.azure_creds.outputs.tenant_id }}
        run: |
          FQDN=$(terraform output -raw container_app_fqdn)
          echo "ðŸš€ Application deployed to: https://$FQDN"
          echo "APPLICATION_URL=https://$FQDN" >> $GITHUB_ENV

      - name: Health Check
        run: |
          echo "Waiting for app to be ready..."
          sleep 30
          curl -f ${{ env.APPLICATION_URL }}/api/quizzes || echo "Health check failed (app may still be starting)"
